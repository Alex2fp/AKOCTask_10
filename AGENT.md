Ты — очень опытный разработчик на C под Linux с глубокими знаниями POSIX threads, синхронизации и создания понятных учебных примеров. Твоя задача — написать полностью работоспособный пример программы, максимально строго реализующей следующую модель (это важно: НЕЛЬЗЯ упрощать до пула потребителей и глобальной суммы):

1. Есть 100 параллельных источников информации (потоков-производителей). Каждый источник:
   - один раз, при старте потока, засыпает на случайное количество секунд от 1 до 7 включительно;
   - после сна генерирует одно случайное целое число в диапазоне от 1 до 100 включительно;
   - помещает это число в общий буфер (ограниченная очередь);
   - пишет информативную строку в лог (на stdout);
   - завершает свою работу.

2. Есть общий буфер целых чисел. Это ограниченная очередь фиксированного размера (например, 128 элементов, но не меньше 100). Буфер должен быть реализован как отдельный модуль с чётким интерфейсом:
   - `void buffer_init(struct buffer *b, size_t capacity);`
   - `void buffer_destroy(struct buffer *b);`
   - `void buffer_put(struct buffer *b, int value);`  // блокирующая вставка
   - `int  buffer_get(struct buffer *b);`            // блокирующее извлечение
   Внутри буфера:
   - массив для хранения значений;
   - индексы head/tail и счётчик элементов;
   - `pthread_mutex_t mutex;`
   - две условные переменные: `pthread_cond_t not_empty;`, `pthread_cond_t not_full;`.
   Логика:
   - `buffer_put`: брать мьютекс; пока буфер полон — ждать `not_full`; класть элемент; сигналить `not_empty`; отпускать мьютекс.
   - `buffer_get`: брать мьютекс; пока буфер пуст — ждать `not_empty`; забирать элемент; сигналить `not_full`; отпускать мьютекс.

3. Есть один отдельный поток-диспетчер, который следит за буфером и создаёт потоки-сумматоры:
   - Диспетчер в цикле проверяет состояние системы и НЕ выполняет активное ожидание (использует мьютекс и condvar’ы).
   - Как только в буфере есть минимум два элемента, диспетчер извлекает две записи (два числа `a` и `b`), уменьшает размер буфера и создаёт новый поток-сумматор. Сумматор получает структуру с:
     - двумя числами `a` и `b`;
     - собственным ID;
     - указателем на буфер;
     - указателями на глобальные счётчики.
   - Диспетчер ведёт счётчик активных сумматоров `active_summators`.
   - Все операции диспетчера по чтению из буфера и проверке условий происходят под мьютексом.
   - Диспетчер завершает работу только тогда, когда выполнено условие окончания: все источники завершили работу, нет активных сумматоров, а в буфере остался ровно один элемент (окончательный результат).

4. Потоки-сумматоры моделируют «обслуживающие устройства»:
   - При старте сумматор пишет в лог строку с указанием своего ID и двух операндов.
   - Затем он спит случайное количество секунд от 3 до 6 включительно.
   - После сна вычисляет `c = a + b`.
   - Кладёт `c` обратно в общий буфер через `buffer_put`.
   - Пишет в лог строку о результате (`a + b = c`, размер буфера до/после вставки).
   - Уменьшает глобальный счётчик `active_summators` под мьютексом и, при необходимости, подаёт сигнал условной переменной, чтобы разбудить диспетчер.
   - Завершает работу.

5. Итоговый критерий завершения всей системы:
   - Все 100 источников отработали и завершили потоки.
   - Все сумматоры завершили работу (`active_summators == 0`).
   - В буфере содержится ровно один элемент.
   - Диспетчер извлекает этот элемент, логирует сообщение вида `RESULT: final value = ...` и устанавливает флаг завершения.
   - Главный поток (`main`) после `pthread_join` диспетчера и всех производителей корректно завершает программу.

Важно: программа НЕ должна использовать упрощённую схему с глобальной переменной `total_sum`, к которой все рабочие просто прибавляют значения. По условию задачи результат должен появиться именно как цепочка суммирований внутри буфера: каждое число многократно перерабатывается сумматорами, пока не останется один элемент.

6. Генерация случайных чисел:
   - В `main` сделать `srand(time(NULL));`.
   - Для потоков использовать или `rand_r` с локальным seed, или общий `rand()` под отдельным мьютексом, чтобы не было гонок. Главное — потокобезопасность.
   - Диапазоны:
     - задержка источников: `sleep` от 1 до 7 (включительно);
     - задержка сумматоров: `sleep` от 3 до 6 (включительно);
     - значения чисел источников: от 1 до 100 включительно.

7. Подробный протокол (лог) на stdout:
   - Лог должен быть читаемым и не перемешанным. Для этого нужно отдельный `log_mutex` и оборачивать каждый `printf` в `pthread_mutex_lock` / `pthread_mutex_unlock`.
   - Формат сообщений (пример, можно немного адаптировать, но нельзя опускать важные детали):
     - запуск системы:
       `[00:00.000] START: launching 100 producers and dispatcher`
     - источник:
       `[00:03.512] PRODUCER #17: generated value 42 after 4 s, buffer_size = 23`
     - диспетчер забрал пару и создал сумматор:
       `[00:05.120] DISPATCHER: took values 35 and 42 (buffer_size before = 10, after = 8), created SUMMATOR #3`
     - сумматор начал работу:
       `[00:05.121] SUMMATOR #3: started with 35 and 42, sleep 4 s`
     - сумматор завершил и вернул сумму в буфер:
       `[00:09.123] SUMMATOR #3: finished, 35 + 42 = 77, buffer_size before = 5, after = 6`
     - финальный результат:
       `[00:30.500] DISPATCHER: final element in buffer`
       `[00:30.500] RESULT: final value = 5073`
       `[00:30.501] STOP: program finished successfully`
   - Желательно выводить относительное время с начала программы (можно в секундах с миллисекундами, через `gettimeofday` или `clock_gettime`).

8. Структура проекта и файлы:
   - `main.c` — инициализация, запуск всех потоков, ожидание завершения, финальный вывод.
   - `buffer.c` / `buffer.h` — реализация общей очереди с мьютексом и condvar’ами.
   - `workers.c` / `workers.h` — функции потоков:
     - `void *producer_thread(void *arg);`
     - `void *dispatcher_thread(void *arg);`
     - `void *summator_thread(void *arg);`
     и все необходимые вспомогательные структуры (аргументы потоков, глобальные счётчики и т.д.).
   - `log.c` / `log.h` — потокобезопасная функция логирования, которая печатает строки с префиксом времени.

9. Makefile:
   - Создать `Makefile` с целями:
     - `all` (по умолчанию собирает исполняемый файл `sum_system`);
     - `clean` (удаляет объектные файлы и бинарник).
   - Пример флагов:
     - `CC = gcc`
     - `CFLAGS = -Wall -Wextra -pedantic -std=c11 -O2`
     - `LDFLAGS = -lpthread`
   - Сборка:
     - `sum_system: main.o buffer.o workers.o log.o`

10. Требования по корректности:
    - Никакого UB: аргументы потокам передавать через `intptr_t` или через выделенные структуры, без арифметики с `(void *)`.
    - Исключить гонки данных (все разделяемые переменные защищены мьютексами).
    - Не использовать активное ожидание; ожидание только через `pthread_cond_wait` или `sleep`.
    - Все созданные потоки должны быть корректно `pthread_join`’нуты (производители и диспетчер), а ресурсы (`mutex`, `condvar`) — уничтожены через `pthread_mutex_destroy`, `pthread_cond_destroy`.

11. Поведение:
    - Программа запускается без аргументов: `./sum_system`.
    - При каждом запуске числа и задержки различаются, но протокол всегда отражает корректную работу алгоритма: в конце в буфере один элемент, соответствующий сумме 100 сгенерированных чисел, и все потоки завершены.

Сгенерируй полный исходный код всех перечисленных файлов и Makefile’а, без заглушек и пропусков, так, чтобы его можно было сразу собрать командой `make` и запустить под Linux.
